# 线程池

## 应用场景

* 在进行创建线程任务时，如果需要频繁的创建线程，销毁线程，这样会极大降低效率，因为创建线程也需要时间，一个完整的线程
  处理时间包括线程的创建时间，运行时间，销毁时间

* 对于频繁创建线程的业务场景，可以预先创建多个线程，在创建线程任务时，可以直接将线程函数添加到预先创建的线程中，这样就可以避免多次创建线程的时间，提高代码运行效率

## 设计思路

设计多线程主要实现的功能有：
1. 预设创建线程的数量

2. 存储运行一定数量线程任务容器变量（可以是vector或其他容器，元素类型是std::thread），该容器一直检测任务队列中是否有待执行的任务，有则取出，无则等待

3. 用于存储运行任务的变量Task（数据类型是queue，数据类型是std::function<T>）,改变量用于存储待运行线程函数func

# 异步编程Futures

Futures功能是并发编程机制，旨在简化多线程编程和异步操作的处理。Futures提供了一种在一个线程中计算值或执行任务，并在另一个线程中获取结果的办法。

核心组件是`std::future`和`std::promise`。`std::future`对象与`std::promise`对象之间共享一个状态。通过`sd::promise`对象设置的值可以通过与其他关联的`std::future`对象来获取，这样就可以使一个线程使用`std::promise`对象来设置异步操作的结果，而另一个线程使用对应的`std::future`对象来获取结果

## std::future
`std:future`提供了一种访问异步操作结果的机制，通过std::async,std::packaged_task或std::promise创建的异步操作可以向该异步操作的创建者提供一个std::future对象。异步操作的创建者可以使用各种方法来查询、等待或从std::future中提取值。

## std::async()
模板函数`std::async`异步地运行函数f（可能在一个独立的线程中，该线程可能是线程池的一部分），并返回一个`std::future`，最终将保存该函数调用的结果。它可以根据系统情况自动选择是独立启动一个线程运行，还是在对应的future调用get时运行；也可以由调用者指定任务调用策略。

任务调用策略：

    std::launch::async; 开启一个独立线程执行任务
    std::launch::deferred; 使用延迟批评估。